#### Redis为什么快

Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器的内存的大小和网络的带宽，而且单线程的性能已经非常高了，就没有必要使用多线程了，所以 Redis 是单进程单线程的。 提示：

如果我们运行的服务器是多核服务器，为了充分利用多核优势我们可以在单台服务器起多个 Redis 服务，或者架设 主从复制、哨兵模式、集群模式等多机方案。

Redis 服务运行时只是处理客户端请求是单进程单线程的，但是服务运行时会有其他进程或线程处理其他的事，比如RDB的文件的生成就会在子进程中进行等。

Redis为什么这么快?

1. 完全基于内存，绝大部分请求是基于内存的操作，而 Redis 的数据结构是类似于HashMap，而 HashMap 的操作时间复杂度是O(1)
2. Redis 数据结构设计简单，方便操作
3. 使用单线程，避免了进程或线程的上下文切换相关的消耗，不用考虑锁相关问题消耗。
4. 使用多路I/O复用模型，非阻塞IO
5. 使用底层模型不同，底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求


#### 什么是多路I/O复用

多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。


#### 注意事项

Redis是基于I/O多路复用的单线程模式，所以 Redis 在处理比较耗时的命令的时候性能会受影响。可以使用 Redis 多机部署方案来应对这样的问题